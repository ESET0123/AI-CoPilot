# Code Review Report

## Executive Summary

This comprehensive code review examined the chatbot application across all modules: Backend (Node.js/Express), Frontend (React), LLM Service (Python/FastAPI), and Theft Detection Service (Python/FastAPI). The review identified **critical security issues**, **potential bugs**, and **opportunities for improvement**.

---

## üî¥ Critical Issues

### 1. **Missing Environment Variable Validation (Backend)**
**File**: [`backend/src/config/env.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/config/env.ts#L22)

**Issue**: `COOKIE_ENCRYPTION_KEY` is marked as required but there's no validation that it's exactly 32 bytes (256 bits) as required by AES-256-GCM.

**Impact**: Application will start successfully but crash at runtime when encryption is attempted.

**Recommendation**:
```typescript
export const env = {
  // ... other vars
  COOKIE_ENCRYPTION_KEY: (() => {
    const key = required('COOKIE_ENCRYPTION_KEY');
    const keyBuffer = Buffer.from(key);
    if (keyBuffer.length !== 32) {
      throw new Error(
        `COOKIE_ENCRYPTION_KEY must be exactly 32 bytes (256 bits). Current: ${keyBuffer.length} bytes. ` +
        `Generate with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"`
      );
    }
    return key;
  })(),
  // ... rest
};
```

### 2. **SQL Injection Risk in Theft Detection Service**
**File**: [`useCases/theftDetectionService/backend/main.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/useCases/theftDetectionService/backend/main.py#L87)

**Issue**: While there are safety checks for banned keywords, the SQL generated by the LLM is executed directly without parameterization. An LLM could potentially be prompt-injected to generate malicious SQL that bypasses keyword filters.

**Current Protection**:
- Keyword blacklist (lines 64-74)
- Single statement check (lines 77-84)

**Vulnerabilities**:
- No protection against `UNION` attacks
- No protection against subqueries
- Regex-based cleaning can be bypassed
- LLM prompt injection could craft SQL that looks safe but isn't

**Recommendation**:
1. Add more comprehensive SQL validation:
```python
# Add to banned keywords
banned = ["delete", "drop", "update", "insert", "alter", "pragma", "union", "attach", "detach"]

# Add validation for suspicious patterns
suspicious_patterns = [
    r"--",  # SQL comments
    r"/\*",  # Multi-line comments
    r"union\s+select",  # UNION attacks
    r"into\s+outfile",  # File operations
    r"load_extension",  # SQLite extensions
]

for pattern in suspicious_patterns:
    if re.search(pattern, clean_sql, re.IGNORECASE):
        return {"success": False, "error": f"Suspicious SQL pattern detected: {pattern}"}
```

2. Consider using a SQL parser library like `sqlparse` to validate structure
3. Implement query result size limits to prevent DoS
4. Add query execution timeout

### 3. **Missing CSRF Protection**
**Files**: 
- [`backend/src/index.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/index.ts)
- [`LLM-service/app/main.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/LLM-service/app/main.py)
- [`useCases/theftDetectionService/backend/main.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/useCases/theftDetectionService/backend/main.py)

**Issue**: None of the services implement CSRF protection, despite using cookies for authentication.

**Impact**: Vulnerable to Cross-Site Request Forgery attacks.

**Recommendation**:
For the backend, add CSRF protection:
```typescript
import csrf from 'csurf';

const csrfProtection = csrf({ 
  cookie: { 
    httpOnly: true, 
    secure: env.NODE_ENV === 'production',
    sameSite: 'strict'
  } 
});

// Apply to state-changing routes
app.use('/api', csrfProtection);
```

---

## üü° High Priority Issues

### 4. **Insufficient Error Information Leakage in Production**
**File**: [`backend/src/index.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/index.ts#L46-L56)

**Issue**: While the global error handler hides stack traces in production, individual controllers may still leak sensitive information.

**Recommendation**: Create a centralized error handling utility:
```typescript
// utils/errors.ts
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true
  ) {
    super(message);
  }
}

export const handleError = (err: Error, res: Response) => {
  if (err instanceof AppError && err.isOperational) {
    return res.status(err.statusCode).json({ message: err.message });
  }
  
  console.error('[Unexpected Error]:', err);
  return res.status(500).json({ 
    message: env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : err.message 
  });
};
```

### 5. **Database Connection Pool Not Properly Initialized**
**File**: [`backend/src/db/pool.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/db/pool.ts)

**Issue**: The pool is created but never tested. If the database is unavailable at startup, the application will start successfully but fail on first query.

**Recommendation**:
```typescript
export const pool = new Pool({
  host: env.DB_HOST,
  port: env.DB_PORT,
  database: env.DB_NAME,
  user: env.DB_USER,
  password: env.DB_PASSWORD,
  max: 20, // Maximum pool size
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Test connection on startup
export const initializeDatabase = async () => {
  try {
    const client = await pool.connect();
    console.log('‚úÖ PostgreSQL connected successfully');
    client.release();
  } catch (error) {
    console.error('‚ùå Failed to connect to PostgreSQL:', error);
    throw error; // Fail fast if DB is unavailable
  }
};
```

Then call `initializeDatabase()` in `index.ts` before starting the server.

### 6. **Race Condition in Token Refresh**
**File**: [`frontend/src/services/axiosClient.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/frontend/src/services/axiosClient.ts#L47-L83)

**Issue**: While the code handles concurrent refresh attempts, there's a potential race condition where `isRefreshing` is set to `false` in the `finally` block, but the queued requests are processed before that.

**Current Code**:
```typescript
try {
  await store.dispatch(refreshAccessToken()).unwrap();
  processQueue(null); // Line 63
  return axiosClient(originalRequest);
} catch (refreshError) {
  processQueue(error); // Line 73
  store.dispatch(logout());
  return Promise.reject(refreshError);
} finally {
  isRefreshing = false; // Line 82
}
```

**Issue**: If a new request comes in between line 63 and line 82, it might incorrectly enter the refresh flow again.

**Recommendation**:
```typescript
try {
  await store.dispatch(refreshAccessToken()).unwrap();
  isRefreshing = false; // Move here
  processQueue(null);
  return axiosClient(originalRequest);
} catch (refreshError) {
  isRefreshing = false; // Move here
  const error = refreshError instanceof Error ? refreshError : new Error('Token refresh failed');
  processQueue(error);
  store.dispatch(logout());
  return Promise.reject(refreshError);
}
```

### 7. **Missing Request Timeout in Theft Detection Service**
**File**: [`useCases/theftDetectionService/backend/llm.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/useCases/theftDetectionService/backend/llm.py#L15)

**Issue**: Timeout is set to 300 seconds (5 minutes), which is extremely long and could lead to resource exhaustion.

**Recommendation**:
```python
# Add configurable timeout with reasonable default
OLLAMA_TIMEOUT = int(os.getenv("OLLAMA_TIMEOUT", "30"))  # 30 seconds default

r = requests.post(url, json=payload, timeout=OLLAMA_TIMEOUT)
```

---

## üü¢ Medium Priority Issues

### 8. **Inconsistent Error Handling in Controllers**
**File**: [`backend/src/controllers/messages.controller.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/controllers/messages.controller.ts)

**Issue**: Some error handlers check for specific error messages (strings), which is fragile and hard to maintain.

**Example** (lines 11-15):
```typescript
if (error.message === 'ACCESS_DENIED') {
  return res.status(403).json({ message: 'Access denied' });
}
```

**Recommendation**: Use custom error classes:
```typescript
// errors/AppError.ts
export class AccessDeniedError extends Error {
  statusCode = 403;
  constructor(message = 'Access denied') {
    super(message);
    this.name = 'AccessDeniedError';
  }
}

// In service
throw new AccessDeniedError();

// In controller
catch (err) {
  if (err instanceof AccessDeniedError) {
    return res.status(err.statusCode).json({ message: err.message });
  }
  // ... handle other errors
}
```

### 9. **No Rate Limiting**
**Files**: All API services

**Issue**: None of the services implement rate limiting, making them vulnerable to DoS attacks and abuse.

**Recommendation**:
For Express backend:
```typescript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', limiter);

// Stricter limit for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  skipSuccessfulRequests: true,
});

app.use('/api/auth/login', authLimiter);
```

For FastAPI services:
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/theftDetection/query")
@limiter.limit("10/minute")
async def query(request: Request, req: QueryReq):
    # ... existing code
```

### 10. **Hardcoded Model Names**
**Files**: 
- [`LLM-service/app/core/config.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/LLM-service/app/core/config.py#L18)
- [`useCases/theftDetectionService/backend/main.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/useCases/theftDetectionService/backend/main.py#L41)

**Issue**: Model name is hardcoded in the theft detection service but configurable in LLM service.

**Recommendation**: Make it consistent and configurable:
```python
# In theft detection service
import os
from dotenv import load_dotenv

load_dotenv()

OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gpt-oss:120b-cloud")

@app.post("/theftDetection/query")
def query(req: QueryReq):
    raw_sql = nl_to_sql(OLLAMA_MODEL, req.prompt)
```

### 11. **Missing Input Validation**
**File**: [`backend/src/controllers/messages.controller.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/controllers/messages.controller.ts#L20-L23)

**Issue**: Basic validation exists but doesn't check for maximum length, which could lead to database errors or DoS.

**Recommendation**:
```typescript
const MAX_MESSAGE_LENGTH = 10000; // 10KB

static async send(req: Request, res: Response) {
  try {
    const { conversationId, message, language } = req.body;
    
    if (!conversationId || !message?.trim()) {
      return res.status(400).json({ message: 'Conversation and message required' });
    }
    
    if (message.length > MAX_MESSAGE_LENGTH) {
      return res.status(400).json({ 
        message: `Message too long. Maximum ${MAX_MESSAGE_LENGTH} characters allowed.` 
      });
    }
    
    // ... rest of the code
  }
}
```

### 12. **No Logging Strategy**
**Issue**: Inconsistent logging across services. Some use `console.log`, some use custom loggers, some have no logging.

**Recommendation**: Implement structured logging with a library like `winston` (Node.js) or Python's `logging` module:

```typescript
// utils/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

if (env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}
```

---

## üîµ Low Priority / Improvements

### 13. **Missing Health Check Details**
**Issue**: Health checks exist but don't verify dependencies (database, Ollama, etc.)

**Recommendation**:
```typescript
// backend/src/routes/health.ts
router.get('/health', async (req, res) => {
  const health = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    services: {
      database: 'unknown',
      aiService: 'unknown',
    }
  };

  try {
    await pool.query('SELECT 1');
    health.services.database = 'healthy';
  } catch (err) {
    health.services.database = 'unhealthy';
    health.status = 'degraded';
  }

  try {
    await aiServiceClient.get('/health', { timeout: 2000 });
    health.services.aiService = 'healthy';
  } catch (err) {
    health.services.aiService = 'unhealthy';
    health.status = 'degraded';
  }

  const statusCode = health.status === 'ok' ? 200 : 503;
  res.status(statusCode).json(health);
});
```

### 14. **Missing Database Indexes**
**Issue**: No information about database indexes. Queries on `conversation_id` and `created_at` should be indexed.

**Recommendation**: Create migration to add indexes:
```sql
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at DESC);
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
```

### 15. **No Request ID Tracking**
**Issue**: Difficult to trace requests across services for debugging.

**Recommendation**: Add request ID middleware:
```typescript
import { v4 as uuidv4 } from 'uuid';

app.use((req, res, next) => {
  req.id = req.headers['x-request-id'] || uuidv4();
  res.setHeader('x-request-id', req.id);
  next();
});
```

### 16. **Whisper Model Pre-loading Could Fail Silently**
**File**: [`LLM-service/app/main.py`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/LLM-service/app/main.py#L21-L25)

**Issue**: Whisper pre-loading failure is logged but doesn't prevent startup. First request will be slow.

**Recommendation**: Consider making it a warning with retry logic:
```python
try:
    whisper_engine.initialize()
    log_with_prefix("Server", "‚úÖ Whisper Engine pre-loaded")
except Exception as e:
    log_with_prefix("Server", f"‚ö†Ô∏è Whisper pre-loading failed: {e}. Will load on first request.", level="warning")
```

### 17. **Missing API Documentation**
**Issue**: No OpenAPI/Swagger documentation for the backend Express API.

**Recommendation**: Add Swagger documentation:
```typescript
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';

const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Chatbot API',
      version: '1.0.0',
    },
  },
  apis: ['./src/routes/*.ts'],
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
```

---

## üìä Performance Recommendations

### 18. **Database Query Optimization**
**File**: [`backend/src/repositories/messages.repository.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/repositories/messages.repository.ts#L12-L28)

**Issue**: Default limit of 50 messages might be too high for initial load.

**Recommendation**: Implement pagination:
```typescript
static async listByConversationId(
  conversationId: string, 
  limit: number = 20,  // Reduced default
  offset: number = 0
): Promise<StoredMessage[]> {
  const result = await pool.query(
    `SELECT id, role, content, created_at
     FROM messages
     WHERE conversation_id = $1
     ORDER BY created_at ASC
     LIMIT $2 OFFSET $3`,
    [conversationId, limit, offset]
  );
  return result.rows;
}
```

### 19. **Connection Pooling Configuration**
**File**: [`backend/src/services/aiServiceClient.ts`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/src/services/aiServiceClient.ts#L16-L30)

**Issue**: Good implementation, but values might need tuning based on load.

**Recommendation**: Make configurable via environment variables:
```typescript
const httpAgent = new http.Agent({
  keepAlive: true,
  keepAliveMsecs: Number(env.HTTP_KEEP_ALIVE_MS) || 30000,
  maxSockets: Number(env.HTTP_MAX_SOCKETS) || 50,
  maxFreeSockets: Number(env.HTTP_MAX_FREE_SOCKETS) || 10,
  timeout: Number(env.HTTP_SOCKET_TIMEOUT) || 60000,
});
```

---

## üîí Security Best Practices

### 20. **Add Security Headers**
**Recommendation**: Add helmet.js to Express backend:
```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));
```

### 21. **Implement Audit Logging**
**Recommendation**: Log security-relevant events:
- Failed login attempts
- Permission denied errors
- Unusual query patterns in theft detection
- Token refresh failures

### 22. **Add Input Sanitization**
**Recommendation**: Sanitize user inputs to prevent XSS:
```typescript
import DOMPurify from 'isomorphic-dompurify';

const sanitizedMessage = DOMPurify.sanitize(message);
```

---

## üìù Code Quality Improvements

### 23. **Add TypeScript Strict Mode**
**File**: [`backend/tsconfig.json`](file:///c:/Users/RishavShah/Desktop/Projects/chatbot/backend/tsconfig.json)

**Recommendation**: Enable strict mode for better type safety:
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true
  }
}
```

### 24. **Add Pre-commit Hooks**
**Recommendation**: Use Husky to enforce code quality:
```json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.ts": ["eslint --fix", "prettier --write"],
    "*.py": ["black", "flake8"]
  }
}
```

### 25. **Add Unit Tests**
**Issue**: No test files found in the project.

**Recommendation**: Add Jest for backend, pytest for Python services:
```bash
# Backend
npm install --save-dev jest @types/jest ts-jest

# Python services
pip install pytest pytest-asyncio pytest-cov
```

---

## üéØ Priority Action Items

### Immediate (Do This Week)
1. ‚úÖ Fix environment variable validation for `COOKIE_ENCRYPTION_KEY`
2. ‚úÖ Add comprehensive SQL injection protection to Theft Detection
3. ‚úÖ Implement CSRF protection
4. ‚úÖ Add database connection testing on startup
5. ‚úÖ Fix token refresh race condition

### Short-term (Do This Month)
6. Add rate limiting to all services
7. Implement structured logging
8. Add custom error classes
9. Add input validation and sanitization
10. Implement health checks with dependency verification

### Long-term (Do This Quarter)
11. Add comprehensive test coverage
12. Implement audit logging
13. Add API documentation
14. Set up monitoring and alerting
15. Implement database migrations system

---

## üìö Additional Resources

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)
- [FastAPI Security](https://fastapi.tiangolo.com/tutorial/security/)
- [PostgreSQL Performance Tuning](https://wiki.postgresql.org/wiki/Performance_Optimization)

---

## Summary

**Total Issues Found**: 25
- üî¥ Critical: 3
- üü° High: 4
- üü¢ Medium: 6
- üîµ Low/Improvements: 12

The codebase is generally well-structured with good separation of concerns. The most critical issues are around security (SQL injection, CSRF, environment validation) and should be addressed immediately. The application would benefit significantly from adding tests, improving error handling, and implementing rate limiting.
